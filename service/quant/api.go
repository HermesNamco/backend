package quant

import (
	"context"
	"errors"
	"fmt"
	"time"

	"backend/models"
)

// SignalType represents different trading signal types
type SignalType string

const (
	// SignalBuy represents a buy signal
	SignalBuy SignalType = "BUY"
	
	// SignalSell represents a sell signal
	SignalSell SignalType = "SELL"
	
	// SignalHold represents a hold signal (no action)
	SignalHold SignalType = "HOLD"
)

// Signal represents a trading signal generated by a strategy
type Signal struct {
	// Type of the signal (BUY, SELL, HOLD)
	Type SignalType `json:"type"`
	
	// Strength of the signal (0.0-1.0), indicating confidence level
	Strength float64 `json:"strength"`
	
	// StockCode for which the signal is generated
	StockCode string `json:"stockCode"`
	
	// Timestamp when the signal was generated
	Timestamp time.Time `json:"timestamp"`
	
	// Price at which the signal was generated (suggested entry/exit)
	Price float64 `json:"price"`
	
	// Additional information about the signal (e.g., reason for the signal)
	Notes string `json:"notes,omitempty"`
	
	// Source strategy that generated the signal
	Strategy string `json:"strategy"`
}

// Position represents an open trading position
type Position struct {
	// StockCode of the position
	StockCode string `json:"stockCode"`
	
	// EntryPrice at which the position was opened
	EntryPrice float64 `json:"entryPrice"`
	
	// CurrentPrice represents the last known price
	CurrentPrice float64 `json:"currentPrice"`
	
	// Quantity of shares/contracts held
	Quantity float64 `json:"quantity"`
	
	// EntryTime when the position was opened
	EntryTime time.Time `json:"entryTime"`
	
	// StopLoss price level for risk management
	StopLoss float64 `json:"stopLoss,omitempty"`
	
	// TakeProfit price target
	TakeProfit float64 `json:"takeProfit,omitempty"`
	
	// UnrealizedPL represents current profit/loss
	UnrealizedPL float64 `json:"unrealizedPL"`
	
	// Strategy that opened the position
	Strategy string `json:"strategy"`
}

// BacktestResult contains performance metrics from strategy backtesting
type BacktestResult struct {
	// StartTime of the backtest period
	StartTime time.Time `json:"startTime"`
	
	// EndTime of the backtest period
	EndTime time.Time `json:"endTime"`
	
	// TotalTrades executed during the backtest
	TotalTrades int `json:"totalTrades"`
	
	// WinningTrades count
	WinningTrades int `json:"winningTrades"`
	
	// LosingTrades count
	LosingTrades int `json:"losingTrades"`
	
	// InitialCapital at the start of backtest
	InitialCapital float64 `json:"initialCapital"`
	
	// FinalCapital at the end of backtest
	FinalCapital float64 `json:"finalCapital"`
	
	// ProfitLoss in absolute terms
	ProfitLoss float64 `json:"profitLoss"`
	
	// ReturnRate as percentage
	ReturnRate float64 `json:"returnRate"`
	
	// MaxDrawdown as percentage
	MaxDrawdown float64 `json:"maxDrawdown"`
	
	// SharpeRatio risk-adjusted return metric
	SharpeRatio float64 `json:"sharpeRatio"`
	
	// Volatility of returns
	Volatility float64 `json:"volatility"`
	
	// Trades list of all executed trades during backtest
	Trades []Trade `json:"trades,omitempty"`
	
	// StrategyName that was backtested
	StrategyName string `json:"strategyName"`
	
	// Parameters used in the strategy
	Parameters map[string]interface{} `json:"parameters"`
}

// Trade represents a completed trade (entry and exit)
type Trade struct {
	// StockCode that was traded
	StockCode string `json:"stockCode"`
	
	// EntryTime when the position was opened
	EntryTime time.Time `json:"entryTime"`
	
	// EntryPrice at which position was opened
	EntryPrice float64 `json:"entryPrice"`
	
	// ExitTime when the position was closed
	ExitTime time.Time `json:"exitTime"`
	
	// ExitPrice at which position was closed
	ExitPrice float64 `json:"exitPrice"`
	
	// Quantity of shares/contracts traded
	Quantity float64 `json:"quantity"`
	
	// Direction of the trade (long/short)
	Direction string `json:"direction"`
	
	// ProfitLoss realized from this trade
	ProfitLoss float64 `json:"profitLoss"`
	
	// ReturnRate as percentage
	ReturnRate float64 `json:"returnRate"`
	
	// HoldingPeriod duration of the trade
	HoldingPeriod time.Duration `json:"holdingPeriod"`
	
	// ExitReason describes why the position was closed
	ExitReason string `json:"exitReason,omitempty"`
}

// StrategyParams represents configuration parameters for a trading strategy
type StrategyParams map[string]interface{}

// DataTimeframe represents the timeframe for market data
type DataTimeframe string

const (
	// Timeframe1Min represents 1-minute data
	Timeframe1Min DataTimeframe = "1m"
	
	// Timeframe5Min represents 5-minute data
	Timeframe5Min DataTimeframe = "5m"
	
	// Timeframe15Min represents 15-minute data
	Timeframe15Min DataTimeframe = "15m"
	
	// Timeframe30Min represents 30-minute data
	Timeframe30Min DataTimeframe = "30m"
	
	// Timeframe1Hour represents 1-hour data
	Timeframe1Hour DataTimeframe = "1h"
	
	// Timeframe4Hour represents 4-hour data
	Timeframe4Hour DataTimeframe = "4h"
	
	// Timeframe1Day represents daily data
	Timeframe1Day DataTimeframe = "1d"
)

// Strategy defines the interface for all trading strategies
type Strategy interface {
	// Initialize sets up the strategy with the given parameters
	Initialize(params StrategyParams) error
	
	// GenerateSignals analyzes market data and generates trading signals
	GenerateSignals(ctx context.Context, stockData []models.Stock) ([]Signal, error)
	
	// ExecuteSignal processes a trading signal and returns resulting position changes
	ExecuteSignal(ctx context.Context, signal Signal, positions []Position) ([]Position, error)
	
	// Backtest runs the strategy against historical data and returns performance metrics
	Backtest(ctx context.Context, stockData []models.Stock, initialCapital float64) (*BacktestResult, error)
	
	// Name returns the unique identifier of this strategy
	Name() string
	
	// Description provides detailed information about the strategy
	Description() string
	
	// DefaultParams returns the default configuration for this strategy
	DefaultParams() StrategyParams
}

// StrategyFactory creates strategy instances
type StrategyFactory interface {
	// CreateStrategy creates a specific strategy instance by its name
	CreateStrategy(name string) (Strategy, error)
	
	// ListAvailableStrategies returns all registered strategy names
	ListAvailableStrategies() []string
	
	// RegisterStrategy adds a strategy to the available strategies
	RegisterStrategy(name string, constructor func() Strategy) error
}

// DataProvider defines the interface for market data access
type DataProvider interface {
	// GetHistoricalData fetches historical stock data for a given time range
	GetHistoricalData(ctx context.Context, stockCode string, start, end time.Time, timeframe DataTimeframe) ([]models.Stock, error)
	
	// GetLatestData fetches the most recent stock data
	GetLatestData(ctx context.Context, stockCode string, timeframe DataTimeframe, bars int) ([]models.Stock, error)
	
	// SubscribeToUpdates registers a callback for real-time data updates
	SubscribeToUpdates(ctx context.Context, stockCode string, timeframe DataTimeframe, callback func(models.Stock) error) (Subscription, error)
}

// Subscription represents a real-time data subscription
type Subscription interface {
	// Unsubscribe cancels the data subscription
	Unsubscribe() error
	
	// IsActive returns whether the subscription is active
	IsActive() bool
}

// DefaultStrategyFactory implements the StrategyFactory interface
type DefaultStrategyFactory struct {
	strategies map[string]func() Strategy
}

// NewStrategyFactory creates a new strategy factory
func NewStrategyFactory() *DefaultStrategyFactory {
	return &DefaultStrategyFactory{
		strategies: make(map[string]func() Strategy),
	}
}

// CreateStrategy instantiates a strategy by name
func (f *DefaultStrategyFactory) CreateStrategy(name string) (Strategy, error) {
	constructor, exists := f.strategies[name]
	if !exists {
		return nil, fmt.Errorf("strategy not found: %s", name)
	}
	return constructor(), nil
}

// ListAvailableStrategies returns all registered strategy names
func (f *DefaultStrategyFactory) ListAvailableStrategies() []string {
	names := make([]string, 0, len(f.strategies))
	for name := range f.strategies {
		names = append(names, name)
	}
	return names
}

// RegisterStrategy adds a strategy to the available strategies
func (f *DefaultStrategyFactory) RegisterStrategy(name string, constructor func() Strategy) error {
	if _, exists := f.strategies[name]; exists {
		return fmt.Errorf("strategy already registered: %s", name)
	}
	f.strategies[name] = constructor
	return nil
}

// Common error types for quantitative strategies
var (
	// ErrStrategyNotInitialized is returned when a strategy is used before initialization
	ErrStrategyNotInitialized = errors.New("strategy not initialized")
	
	// ErrInvalidParameters is returned when strategy parameters are invalid
	ErrInvalidParameters = errors.New("invalid strategy parameters")
	
	// ErrInsufficientData is returned when not enough data is available for analysis
	ErrInsufficientData = errors.New("insufficient data for strategy analysis")
	
	// ErrBacktestFailed is returned when backtest execution fails
	ErrBacktestFailed = errors.New("backtest execution failed")
	
	// ErrInvalidTimeframe is returned for an unsupported timeframe
	ErrInvalidTimeframe = errors.New("invalid or unsupported timeframe")
	
	// ErrInvalidSignal is returned when the signal format is invalid
	ErrInvalidSignal = errors.New("invalid trading signal format")
)

// StrategyError wraps strategy-specific errors with additional context
type StrategyError struct {
	Err        error  // Original error
	Message    string // Error message
	StrategyID string // ID of the strategy that generated the error
}

// Error satisfies the error interface
func (e *StrategyError) Error() string {
	return fmt.Sprintf("[%s] %s: %v", e.StrategyID, e.Message, e.Err)
}

// Unwrap returns the original error
func (e *StrategyError) Unwrap() error {
	return e.Err
}