package quant

import (
	"context"
	"errors"
	"fmt"
	"time"

	"backend/models"
)

// Signal represents a trading signal generated by a strategy
type Signal struct {
	// Type of the signal (BUY, SELL, HOLD)
	Type SignalType `json:"type"`

	// Strength of the signal (0.0-1.0), indicating confidence level
	Strength float64 `json:"strength"`

	// StockCode for which the signal is generated
	StockCode string `json:"stockCode"`

	// Timestamp when the signal was generated
	Timestamp time.Time `json:"timestamp"`

	// Price at which the signal was generated (suggested entry/exit)
	Price float64 `json:"price"`

	// Additional information about the signal (e.g., reason for the signal)
	Notes string `json:"notes,omitempty"`

	// Source strategy that generated the signal
	Strategy string `json:"strategy"`
}

// Position represents an open trading position
type Position struct {
	// StockCode of the position
	StockCode string `json:"stockCode"`

	// EntryPrice at which the position was opened
	EntryPrice float64 `json:"entryPrice"`

	// CurrentPrice represents the last known price
	CurrentPrice float64 `json:"currentPrice"`

	// Quantity of shares/contracts held
	Quantity float64 `json:"quantity"`

	// EntryTime when the position was opened
	EntryTime time.Time `json:"entryTime"`

	// StopLoss price level for risk management
	StopLoss float64 `json:"stopLoss,omitempty"`

	// TakeProfit price target
	TakeProfit float64 `json:"takeProfit,omitempty"`

	// UnrealizedPL represents current profit/loss
	UnrealizedPL float64 `json:"unrealizedPL"`

	// Strategy that opened the position
	Strategy string `json:"strategy"`
}

// BacktestResult contains performance metrics from strategy backtesting
type BacktestResult struct {
	// StartTime of the backtest period
	StartTime time.Time `json:"startTime"`

	// EndTime of the backtest period
	EndTime time.Time `json:"endTime"`

	// TotalTrades executed during the backtest
	TotalTrades int `json:"totalTrades"`

	// WinningTrades count
	WinningTrades int `json:"winningTrades"`

	// LosingTrades count
	LosingTrades int `json:"losingTrades"`

	// InitialCapital at the start of backtest
	InitialCapital float64 `json:"initialCapital"`

	// FinalCapital at the end of backtest
	FinalCapital float64 `json:"finalCapital"`

	// ProfitLoss in absolute terms
	ProfitLoss float64 `json:"profitLoss"`

	// ReturnRate as percentage
	ReturnRate float64 `json:"returnRate"`

	// MaxDrawdown as percentage
	MaxDrawdown float64 `json:"maxDrawdown"`

	// SharpeRatio risk-adjusted return metric
	SharpeRatio float64 `json:"sharpeRatio"`

	// Volatility of returns
	Volatility float64 `json:"volatility"`

	// Trades list of all executed trades during backtest
	Trades []Trade `json:"trades,omitempty"`

	// StrategyName that was backtested
	StrategyName string `json:"strategyName"`

	// Parameters used in the strategy
	Parameters map[string]interface{} `json:"parameters"`
}

// Trade represents a completed trade (entry and exit)
type Trade struct {
	// StockCode that was traded
	StockCode string `json:"stockCode"`

	// EntryTime when the position was opened
	EntryTime time.Time `json:"entryTime"`

	// EntryPrice at which position was opened
	EntryPrice float64 `json:"entryPrice"`

	// ExitTime when the position was closed
	ExitTime time.Time `json:"exitTime"`

	// ExitPrice at which position was closed
	ExitPrice float64 `json:"exitPrice"`

	// Quantity of shares/contracts traded
	Quantity float64 `json:"quantity"`

	// Direction of the trade (long/short)
	Direction string `json:"direction"`

	// ProfitLoss realized from this trade
	ProfitLoss float64 `json:"profitLoss"`

	// ReturnRate as percentage
	ReturnRate float64 `json:"returnRate"`

	// HoldingPeriod duration of the trade
	HoldingPeriod time.Duration `json:"holdingPeriod"`

	// ExitReason describes why the position was closed
	ExitReason string `json:"exitReason,omitempty"`

	//
	Strategy string `json:"strategy"`
}

// StrategyParams represents configuration parameters for a trading strategy
type StrategyParams map[string]interface{}

// Strategy defines the interface for all trading strategies
type Strategy interface {
	// Initialize sets up the strategy with the given parameters
	Initialize(params StrategyParams) error

	// GenerateSignals analyzes market data and generates trading signals
	GenerateSignals(ctx context.Context, stockData []models.Stock) ([]Signal, error)

	// ExecuteSignal processes a trading signal and returns resulting position changes
	ExecuteSignal(ctx context.Context, signal Signal, positions []Position) ([]Position, error)

	// Backtest runs the strategy against historical data and returns performance metrics
	Backtest(ctx context.Context, stockData []models.Stock, initialCapital float64) (*BacktestResult, error)

	// Name returns the unique identifier of this strategy
	Name() string

	// Description provides detailed information about the strategy
	Description() string

	// DefaultParams returns the default configuration for this strategy
	DefaultParams() StrategyParams
}

// StrategyFactory creates strategy instances
type StrategyFactory interface {
	// CreateStrategy creates a specific strategy instance by its name
	CreateStrategy(name string) (Strategy, error)

	// ListAvailableStrategies returns all registered strategy names
	ListAvailableStrategies() []string

	// RegisterStrategy adds a strategy to the available strategies
	RegisterStrategy(name string, constructor func() Strategy) error
}

// DataProvider defines the interface for market data access
type DataProvider interface {
	// GetHistoricalData fetches historical stock data for a given time range
	GetHistoricalData(ctx context.Context, stockCode string, start, end time.Time, timeframe DataTimeframe) ([]models.Stock, error)

	// GetLatestData fetches the most recent stock data
	GetLatestData(ctx context.Context, stockCode string, timeframe DataTimeframe, bars int) ([]models.Stock, error)

	// SubscribeToUpdates registers a callback for real-time data updates
	SubscribeToUpdates(ctx context.Context, stockCode string, timeframe DataTimeframe, callback func(models.Stock) error) (Subscription, error)
}

// Subscription represents a real-time data subscription
type Subscription interface {
	// Unsubscribe cancels the data subscription
	Unsubscribe() error

	// IsActive returns whether the subscription is active
	IsActive() bool
}

// DefaultStrategyFactory implements the StrategyFactory interface
type DefaultStrategyFactory struct {
	strategies map[string]func() Strategy
}

// NewStrategyFactory creates a new strategy factory
func NewStrategyFactory() *DefaultStrategyFactory {
	return &DefaultStrategyFactory{
		strategies: make(map[string]func() Strategy),
	}
}

// CreateStrategy instantiates a strategy by name
func (f *DefaultStrategyFactory) CreateStrategy(name string) (Strategy, error) {
	constructor, exists := f.strategies[name]
	if !exists {
		return nil, fmt.Errorf("strategy not found: %s", name)
	}
	return constructor(), nil
}

// ListAvailableStrategies returns all registered strategy names
func (f *DefaultStrategyFactory) ListAvailableStrategies() []string {
	names := make([]string, 0, len(f.strategies))
	for name := range f.strategies {
		names = append(names, name)
	}
	return names
}

// RegisterStrategy adds a strategy to the available strategies
func (f *DefaultStrategyFactory) RegisterStrategy(name string, constructor func() Strategy) error {
	if _, exists := f.strategies[name]; exists {
		return fmt.Errorf("strategy already registered: %s", name)
	}
	f.strategies[name] = constructor
	return nil
}

// Common error types for quantitative strategies
var (
	// ErrStrategyNotInitialized is returned when a strategy is used before initialization
	ErrStrategyNotInitialized = errors.New("strategy not initialized")

	// ErrInvalidParameters is returned when strategy parameters are invalid
	ErrInvalidParameters = errors.New("invalid strategy parameters")

	// ErrInsufficientData is returned when not enough data is available for analysis
	ErrInsufficientData = errors.New("insufficient data for strategy analysis")

	// ErrBacktestFailed is returned when backtest execution fails
	ErrBacktestFailed = errors.New("backtest execution failed")

	// ErrInvalidTimeframe is returned for an unsupported timeframe
	ErrInvalidTimeframe = errors.New("invalid or unsupported timeframe")

	// ErrInvalidSignal is returned when the signal format is invalid
	ErrInvalidSignal = errors.New("invalid trading signal format")
)

// StrategyError wraps strategy-specific errors with additional context
type StrategyError struct {
	Err        error  // Original error
	Message    string // Error message
	StrategyID string // ID of the strategy that generated the error
}

// Error satisfies the error interface
func (e *StrategyError) Error() string {
	return fmt.Sprintf("[%s] %s: %v", e.StrategyID, e.Message, e.Err)
}

// Unwrap returns the original error
func (e *StrategyError) Unwrap() error {
	return e.Err
}
