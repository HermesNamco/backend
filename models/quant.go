package models

import (
	"encoding/json"
	"time"

	"backend/service/quant" // For quant.SignalType, etc.
)

// SignalType represents the type of trading signal.
// This is a local copy or reference to the one in service/quant if direct import is not desired for models package.
// For this implementation, we assume service/quant.SignalType can be used, or we redefine it.
// type SignalType string

// const (
// 	SignalBuy  SignalType = "BUY"
// 	SignalSell SignalType = "SELL"
// 	SignalHold SignalType = "HOLD"
// )

// Signal represents a trading signal generated by a strategy.
// It mirrors quant.Signal but resides in the models package for data persistence or API exposure.
type Signal struct {
	ID        string             `json:"id,omitempty" bson:"_id,omitempty"` // Unique ID for the signal
	StockCode string             `json:"stockCode" bson:"stockCode"`         // Stock symbol
	Strategy  string             `json:"strategy" bson:"strategy"`           // Name of the strategy generating the signal
	Type      quant.SignalType   `json:"type" bson:"type"`                   // BUY, SELL, HOLD
	Price     float64            `json:"price" bson:"price"`                 // Price at which the signal was generated
	Timestamp time.Time          `json:"timestamp" bson:"timestamp"`           // Time of signal generation
	Strength  float64            `json:"strength,omitempty" bson:"strength,omitempty"` // Confidence level (0.0 to 1.0)
	Notes     string             `json:"notes,omitempty" bson:"notes,omitempty"`         // Additional details
	Metadata  map[string]string `json:"metadata,omitempty" bson:"metadata,omitempty"` // Any other relevant info
}

// Position represents an open trading position for a stock.
// Mirrors quant.Position.
type Position struct {
	ID           string    `json:"id,omitempty" bson:"_id,omitempty"`              // Unique ID for the position
	StockCode    string    `json:"stockCode" bson:"stockCode"`                // Stock symbol
	Quantity     float64   `json:"quantity" bson:"quantity"`                  // Number of shares/contracts held
	EntryPrice   float64   `json:"entryPrice" bson:"entryPrice"`              // Average price at which the position was entered
	EntryTime    time.Time `json:"entryTime" bson:"entryTime"`                // Time of initial entry
	CurrentPrice float64   `json:"currentPrice,omitempty" bson:"currentPrice,omitempty"` // Last known market price
	Strategy     string    `json:"strategy,omitempty" bson:"strategy,omitempty"`       // Strategy that opened/manages this position
	Direction    string    `json:"direction" bson:"direction"`                  // "LONG" or "SHORT"
	StopLoss     float64   `json:"stopLoss,omitempty" bson:"stopLoss,omitempty"`       // Stop-loss price level
	TakeProfit   float64   `json:"takeProfit,omitempty" bson:"takeProfit,omitempty"`   // Take-profit price level
	UnrealizedPL float64   `json:"unrealizedPL,omitempty" bson:"unrealizedPL,omitempty"` // Current unrealized profit/loss
	UpdatedAt    time.Time `json:"updatedAt,omitempty" bson:"updatedAt,omitempty"`      // Last update time
}

// Trade represents an executed trade, forming part of a position lifecycle.
// Mirrors quant.Trade.
type Trade struct {
	ID            string    `json:"id,omitempty" bson:"_id,omitempty"`                       // Unique ID for the trade
	PositionID    string    `json:"positionId,omitempty" bson:"positionId,omitempty"`       // Associated position ID
	StockCode     string    `json:"stockCode" bson:"stockCode"`                         // Stock symbol
	Strategy      string    `json:"strategy,omitempty" bson:"strategy,omitempty"`                // Strategy that executed the trade
	Direction     string    `json:"direction" bson:"direction"`                           // "BUY" to open/add, "SELL" to close/reduce (for long)
	Quantity      float64   `json:"quantity" bson:"quantity"`                           // Number of shares/contracts traded
	Price         float64   `json:"price" bson:"price"`                                  // Execution price
	Timestamp     time.Time `json:"timestamp" bson:"timestamp"`                            // Time of trade execution
	Commission    float64   `json:"commission,omitempty" bson:"commission,omitempty"`          // Trading commission paid
	Slippage      float64   `json:"slippage,omitempty" bson:"slippage,omitempty"`              // Slippage incurred
	NetProfitLoss float64   `json:"netProfitLoss,omitempty" bson:"netProfitLoss,omitempty"`    // P&L for this trade if it closes/reduces a position
	Notes         string    `json:"notes,omitempty" bson:"notes,omitempty"`                      // Additional details about the trade
}

// StrategyConfig stores the configuration parameters for a given trading strategy.
// It's designed to be serializable (e.g., to JSON or database).
type StrategyConfig struct {
	ID             string                 `json:"id,omitempty" bson:"_id,omitempty"`           // Unique ID for this configuration instance
	StrategyName   string                 `json:"strategyName" bson:"strategyName"`         // Name of the strategy (e.g., "MACross", "RSIStrategy")
	StockCodes     []string               `json:"stockCodes" bson:"stockCodes"`             // List of stock codes this strategy applies to
	Timeframe      quant.DataTimeframe    `json:"timeframe" bson:"timeframe"`               // Data timeframe (e.g., "1m", "1h", "1d")
	Parameters     map[string]interface{} `json:"parameters" bson:"parameters"`           // Strategy-specific parameters (e.g., {"fastPeriod": 10, "slowPeriod": 30})
	IsActive       bool                   `json:"isActive" bson:"isActive"`                 // Whether this strategy configuration is currently active
	CreatedAt      time.Time              `json:"createdAt,omitempty" bson:"createdAt,omitempty"` // Creation timestamp
	UpdatedAt      time.Time              `json:"updatedAt,omitempty" bson:"updatedAt,omitempty"`   // Last update timestamp
	Description    string                 `json:"description,omitempty" bson:"description,omitempty"` // Optional description
}

// Serialize marshals StrategyConfig to JSON string.
func (sc *StrategyConfig) Serialize() (string, error) {
	data, err := json.Marshal(sc)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// Deserialize unmarshals JSON string to StrategyConfig.
func (sc *StrategyConfig) Deserialize(jsonData string) error {
	return json.Unmarshal([]byte(jsonData), sc)
}

// PerformanceMetrics stores various metrics to evaluate a strategy or portfolio.
// Mirrors quant.BacktestResult but is generalized.
type PerformanceMetrics struct {
	ID             string                 `json:"id,omitempty" bson:"_id,omitempty"`          // Unique ID for this metrics record
	EntityID       string                 `json:"entityId" bson:"entityId"`                 // ID of the strategy, portfolio, or asset being measured
	EntityType     string                 `json:"entityType" bson:"entityType"`             // "strategy", "portfolio", "asset"
	PeriodStart    time.Time              `json:"periodStart" bson:"periodStart"`          // Start of the measurement period
	PeriodEnd      time.Time              `json:"periodEnd" bson:"periodEnd"`            // End of the measurement period
	InitialCapital float64                `json:"initialCapital" bson:"initialCapital"`     // Capital at the start
	FinalCapital   float64                `json:"finalCapital" bson:"finalCapital"`         // Capital at the end
	TotalTrades    int                    `json:"totalTrades" bson:"totalTrades"`           // Total number of trades executed
	WinningTrades  int                    `json:"winningTrades" bson:"winningTrades"`       // Number of profitable trades
	LosingTrades   int                    `json:"losingTrades" bson:"losingTrades"`         // Number of losing trades
	WinRate        float64                `json:"winRate" bson:"winRate"`                   // WinningTrades / TotalTrades
	AvgWin         float64                `json:"avgWin" bson:"avgWin"`                     // Average profit of winning trades
	AvgLoss        float64                `json:"avgLoss" bson:"avgLoss"`                   // Average loss of losing trades
	ProfitFactor   float64                `json:"profitFactor" bson:"profitFactor"`         // Gross Profit / Gross Loss
	NetProfit      float64                `json:"netProfit" bson:"netProfit"`               // Total net profit or loss
	ReturnRate     float64                `json:"returnRate" bson:"returnRate"`             // Percentage return over the period
	MaxDrawdown    float64                `json:"maxDrawdown" bson:"maxDrawdown"`           // Maximum peak-to-trough decline (percentage)
	SharpeRatio    float64                `json:"sharpeRatio" bson:"sharpeRatio"`           // Risk-adjusted return (annualized if applicable)
	SortinoRatio   float64                `json:"sortinoRatio,omitempty" bson:"sortinoRatio,omitempty"` // Downside risk-adjusted return
	Volatility     float64                `json:"volatility,omitempty" bson:"volatility,omitempty"`   // Standard deviation of returns
	Trades         []Trade                `json:"trades,omitempty" bson:"trades,omitempty"` // Optional: list of trades for detailed analysis
	Parameters     map[string]interface{} `json:"parameters,omitempty" bson:"parameters,omitempty"` // Parameters used if this is for a strategy backtest
	GeneratedAt    time.Time              `json:"generatedAt" bson:"generatedAt"`           // Timestamp when these metrics were generated
}

// PortfolioAsset represents a single asset held within a portfolio.
type PortfolioAsset struct {
	StockCode     string  `json:"stockCode" bson:"stockCode"`         // Asset's stock code
	Quantity      float64 `json:"quantity" bson:"quantity"`          // Quantity held
	AverageCost   float64 `json:"averageCost" bson:"averageCost"`     // Average cost basis of the holding
	MarketValue   float64 `json:"marketValue" bson:"marketValue"`     // Current market value of the holding
	UnrealizedPL  float64 `json:"unrealizedPL" bson:"unrealizedPL"`   // Unrealized profit or loss
	PortfolioWeight float64 `json:"portfolioWeight" bson:"portfolioWeight"` // Percentage of total portfolio value
}

// Portfolio represents a collection of assets and cash.
type Portfolio struct {
	ID               string                    `json:"id,omitempty" bson:"_id,omitempty"`      // Unique ID for the portfolio
	Name             string                    `json:"name" bson:"name"`                      // Name of the portfolio (e.g., "Growth", "Income")
	OwnerID          string                    `json:"ownerId,omitempty" bson:"ownerId,omitempty"`  // User or entity owning the portfolio
	CashBalance      float64                   `json:"cashBalance" bson:"cashBalance"`          // Available cash
	TotalValue       float64                   `json:"totalValue" bson:"totalValue"`            // Total market value of the portfolio (cash + assets)
	Assets           map[string]PortfolioAsset `json:"assets" bson:"assets"`                  // Map of stockCode to PortfolioAsset
	Performance      PerformanceMetrics        `json:"performance,omitempty" bson:"performance,omitempty"` // Overall portfolio performance metrics
	RiskParameters   map[string]interface{}    `json:"riskParameters,omitempty" bson:"riskParameters,omitempty"` // Portfolio-level risk settings
	TargetAllocation map[string]float64        `json:"targetAllocation,omitempty" bson:"targetAllocation,omitempty"` // Target asset allocation percentages
	CreatedAt        time.Time                 `json:"createdAt,omitempty" bson:"createdAt,omitempty"`    // Creation timestamp
	UpdatedAt        time.Time                 `json:"updatedAt,omitempty" bson:"updatedAt,omitempty"`      // Last update timestamp
}

// MarketData is a generic structure for providing market data to technical indicators.
// This is similar to models.Stock but might be adapted for broader use or different data frequencies.
type MarketData struct {
	Timestamp time.Time `json:"timestamp" bson:"timestamp"` // Data point timestamp
	Open      float64   `json:"open" bson:"open"`             // Opening price
	High      float64   `json:"high" bson:"high"`             // Highest price
	Low       float64   `json:"low" bson:"low"`               // Lowest price
	Close     float64   `json:"close" bson:"close"`           // Closing price
	Volume    float64   `json:"volume" bson:"volume"`         // Trading volume (can be float for crypto/forex)
	VWAP      float64   `json:"vwap,omitempty" bson:"vwap,omitempty"` // Volume Weighted Average Price (optional)
}

// OHLCV is a convenience type, often used directly by indicator libraries.
type OHLCV struct {
	Open      []float64
	High      []float64
	Low       []float64
	Close     []float64
	Volume    []float64
	Timestamp []time.Time
}

// ConvertStockToMarketData converts a slice of models.Stock to a slice of MarketData.
func ConvertStockToMarketData(stocks []Stock) []MarketData {
	marketDataSlice := make([]MarketData, len(stocks))
	for i, s := range stocks {
		marketDataSlice[i] = MarketData{
			Timestamp: s.Timestamp,
			Open:      s.Open,
			High:      s.High,
			Low:       s.Low,
			Close:     s.Close,
			Volume:    float64(s.Volume), // Convert int64 to float64
		}
	}
	return marketDataSlice
}

// ConvertMarketDataToOHLCV converts a slice of MarketData to OHLCV struct.
func ConvertMarketDataToOHLCV(data []MarketData) OHLCV {
	ohlcv := OHLCV{
		Open:      make([]float64, len(data)),
		High:      make([]float64, len(data)),
		Low:       make([]float64, len(data)),
		Close:     make([]float64, len(data)),
		Volume:    make([]float64, len(data)),
		Timestamp: make([]time.Time, len(data)),
	}
	for i, d := range data {
		ohlcv.Open[i] = d.Open
		ohlcv.High[i] = d.High
		ohlcv.Low[i] = d.Low
		ohlcv.Close[i] = d.Close
		ohlcv.Volume[i] = d.Volume
		ohlcv.Timestamp[i] = d.Timestamp
	}
	return ohlcv
}

// PersistStrategyConfig is a placeholder for saving strategy configuration.
// In a real application, this would interact with a database or file system.
func PersistStrategyConfig(config StrategyConfig) error {
	// Example: Save to a JSON file or database.
	// For now, just demonstrates the concept.
	jsonData, err := config.Serialize()
	if err != nil {
		return err
	}
	// In a real scenario: ioutil.WriteFile("strategy_"+config.ID+".json", []byte(jsonData), 0644)
	_ = jsonData // Avoid unused variable error
	// log.Printf("Persisted strategy config %s: %s", config.ID, jsonData)
	return nil
}

// LoadStrategyConfig is a placeholder for loading strategy configuration.
func LoadStrategyConfig(id string) (*StrategyConfig, error) {
	// Example: Load from a JSON file or database.
	// For now, returns a dummy config or error.
	// In a real scenario: data, err := ioutil.ReadFile("strategy_"+id+".json")
	// var config StrategyConfig
	// err = config.Deserialize(string(data))
	// return &config, err
	return nil, errors.New("LoadStrategyConfig not implemented")
}
